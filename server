#!/bin/bash

GPG_RECIPIENT="$USER"
SSH_CONFIG_FILE="$HOME/.ssh/config"
CRED_FILE="$HOME/.ssh/server_credentials"
backup_dir="./serverctx_backup"

server_init() {
    # make sure fzf installed
    if ! command -v fzf &>/dev/null; then
        sudo apt update -y && sudo apt install fzf -y
    fi
    # make sure gpg installed
    if ! command -v gpg &>/dev/null; then
        sudo apt update -y && sudo apt install gnupg -y
    fi
    # maske sure sshpass installed
    if ! command -v sshpass &>/dev/null; then
        sudo apt install sshpass -y
    fi
    # make sure xclip installed
    if ! command -v xclip &>/dev/null; then
        sudo apt install xclip -y
    fi

    # make sure gpg is initialized
    if ! gpg --list-keys | grep -q '^pub'; then
        echo "üîë Please Follow The Prompts To Initialize your Encryption Keys"
        echo;echo; 
        echo "SUGGESTIONS"
        echo "you can choose the default options for most prompts."
        echo "key type  :  choose 'RSA and RSA'."
        echo "key size  :  choose 2048 or 4096 bits"
        echo "expiration:  choose '0' for no expiration."
        echo "passphrase:  choose a strong passphrase to encrypt your passwords."
        echo;echo;
        
        gpg --full-generate-key
    fi
    # make sure ~/.ssh exists
    if [[ ! -d "$HOME/.ssh" ]]; then
        mkdir -p "$HOME/.ssh"
    fi
    # make sure ~/.ssh/config exists
    if [[ ! -f "$SSH_CONFIG_FILE" ]]; then
        touch "$SSH_CONFIG_FILE"
    fi
    # make sure ~/.ssh/server_credentials exists
    if [[ ! -f "$CRED_FILE" ]]; then
        touch "$CRED_FILE"
    fi

    echo "‚úÖ Server Manager Initialized"
    echo;
    echo "You can now add, remove, edit, and connect to SSH servers."
    echo "Use 'server --help' to see available commands."

}

# Function to encrypt pswrd
encrypt_password() {
    local plain="$1"
    echo -n "$plain" | gpg --yes -r "$GPG_RECIPIENT" -e --armor | base64 | tr -d '\n'
}

# Function to decrypt pswrd
decrypt_password() {
    local encrypted="$1"
    echo "$encrypted" | base64 --decode | gpg --quiet --decrypt
}

function add_server() {
    # no empty input should be allowed
    while true; do
        read -p "Server name (alias): " name
        if [[ -n "$name" ]]; then
            break
        else
            echo "‚ùå Server name cannot be empty. Please try again."
        fi
    done

    while true; do
        read -p "HostName (IP or domain): " hostname
        if [[ -n "$hostname" ]]; then
            break
        else
            echo "‚ùå HostName cannot be empty. Please try again."
        fi
    done

    while true; do
        read -p "User: " user
        if [[ -n "$user" ]]; then
            break
        else
            echo "‚ùå User cannot be empty. Please try again."
        fi
    done

    while true; do
        read -p "Port (optional, default 22): " port
        port=${port:-22}
        if [[ "$port" =~ ^[0-9]+$ ]]; then
            break
        else
            echo "‚ùå Port must be a number. Try again."
        fi
    done

    read -p "Enter group (optional): " group
    group=${group:-default}


    if grep -q "^Host $name\$" "$SSH_CONFIG_FILE" 2>/dev/null; then
        echo "‚ùå Host '$name' already exists in ~/.ssh/config"
        return 1
    fi

    read -rsp "Enter password: " password
    echo

    # Only proceed if password is provided
    if [[ -n "$password" ]]; then
        encrypted_password=$(encrypt_password "$password")
        echo "$group-$name=$encrypted_password" >> "$CRED_FILE"
        echo "‚úÖ Added: $name"
    else
        echo
    read -p "Enter path to private key: " private_key

    if [[ -n "$private_key" ]]; then
        mkdir -p "$HOME/.ssh/keys"

        while [[ ! -f "$private_key" ]]; do
            echo "‚ùå File '$private_key' not found. Please try again."
            read -p "Enter path to private key (or press Enter to skip): " private_key
        done
        if [[ -n "$private_key" ]]; then
            # Valid file found
            cp "$private_key" "$HOME/.ssh/keys/$group-$name"
            chmod 600 "$HOME/.ssh/keys/$group-$name"
            echo
            echo "‚úÖ Private key saved to $HOME/.ssh/keys/$group-$name"
        else
            echo
            echo "‚ö†Ô∏è No ssh key path provided. Skipping SSH Key setup."
        fi
    fi
    fi

    mkdir -p ~/.ssh

    grouplname="$group/$name"
    {
        echo ""
        echo "Host $grouplname"
        echo "    HostName $hostname"
        echo "    User $user"
        echo "    Port $port"
    } >> "$SSH_CONFIG_FILE"

}

function remove_server() {
    local hosts groups group selected_host full_host

    # Get all hosts in format group/name
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        return 1
    fi

    # Extract unique groups (portion before '/')
    groups=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u)
    if [[ -z "$groups" ]]; then
        echo "‚ùå No groups found in hosts"
        return 1
    fi

    # Select group
    group=$(echo "$groups" | fzf --prompt="Select group to remove host from: ")
    if [[ -z "$group" ]]; then
        echo "‚ùå No group selected."
        return 1
    fi

    # Select host in the chosen group
    selected_host=$(echo "$hosts" | grep "^$group/" | awk -F/ '{print $2}' | fzf --prompt="Select host in group '$group' to remove: ")
    if [[ -z "$selected_host" ]]; then
        echo "‚ùå No host selected."
        return 1
    fi

    full_host="$group/$selected_host"

    # Remove host block from SSH config
    awk -v host="$full_host" '
        BEGIN {skip=0}
        $1 == "Host" && $2 == host {skip=1; next}
        $1 == "Host" {skip=0}
        !skip {print}
    ' "$SSH_CONFIG_FILE" > "${SSH_CONFIG_FILE}.tmp" && mv "${SSH_CONFIG_FILE}.tmp" "$SSH_CONFIG_FILE"

    echo "‚úÖ $selected_host  Deleted"

    # Remove password entry from credentials file if exists
    if grep -q "^$group-$selected_host=" "$CRED_FILE"; then
        sed -i "/^$group-$selected_host=/d" "$CRED_FILE"
    fi  
    # remove ssh key if exists
    if [[ -f ~/.ssh/keys/$group-$selected_host ]]; then
        rm ~/.ssh/keys/$group-$selected_host
    fi

}

function list_servers() {
    declare -A host_map
    declare -A status_map
    declare -A pw_status_map
    declare -A key_status_map
    declare -A group_servers

    current_host=""

    # Read SSH config and build host_map
    while IFS= read -r line; do
        line_trimmed="${line#"${line%%[![:space:]]*}"}"
        line_trimmed="${line_trimmed%"${line_trimmed##*[![:space:]]}"}"
        [[ -z "$line_trimmed" || "$line_trimmed" =~ ^# ]] && continue

        if [[ "$line_trimmed" =~ ^Host[[:space:]]+(.+) ]]; then
            current_host="${BASH_REMATCH[1]}"
        elif [[ -n "$current_host" ]] && [[ "$line_trimmed" =~ ^HostName[[:space:]]+(.+) ]]; then
            host_map["$current_host"]="${BASH_REMATCH[1]}"
        fi
    done < "$SSH_CONFIG_FILE"

    # Temporary dir to hold ping results
    tmpdir=$(mktemp -d)

    ping_host() {
        local alias=$1
        local hostname=$2
        if ping -c1 -W1 "$hostname" &>/dev/null; then
            echo "üü¢ Online" > "$tmpdir/$alias.status"

        else
            echo "üî¥ Offline" > "$tmpdir/$alias.status"
        fi
    }
    
    for alias in "${!host_map[@]}"; do
        servername=$(echo "$alias" | cut -d'/' -f2)

        ping_host "$servername" "${host_map[$alias]}" &
    done
    
    wait

    # Determine max alias length for formatting
    max_alias_length=0
    for alias in "${!host_map[@]}"; do
        servername=$(echo "$alias" | cut -d'/' -f2)
        [ "${#servername}" -gt "$max_alias_length" ] && max_alias_length="${#servername}"
    done
    max_alias_length=$((max_alias_length + 2))

    # Populate status, password, and key status maps
    for alias in "${!host_map[@]}"; do
        servername2=$(echo "$alias" | cut -d'/' -f2)
        servernamedash=$(echo "$alias" | sed 's/\//-/g')

        # Ping status
        status=$(cat "$tmpdir/$servername2.status")

        # Password status
        if grep -q "^$servernamedash=" "$CRED_FILE"; then
            pw_status="üîí"
        else
            pw_status="‚ùå"
        fi

        # SSH key status
        if [[ -f "$HOME/.ssh/keys/$servernamedash" ]]; then
            key_status="üîë"
        else
            key_status="‚ùå"
        fi

        status_map["$alias"]="$status"
        pw_status_map["$alias"]="$pw_status"
        key_status_map["$alias"]="$key_status"

        group=$(echo "$alias" | cut -d'/' -f1)
        group_servers["$group"]+="$alias"$'\n'
    done

    # Print servers grouped
    count=0
    for group in $(printf "%s\n" "${!group_servers[@]}" | sort); do
        echo -e "\nüóÇÔ∏è  Group: \033[1;36m$group\033[0m"
        while IFS= read -r alias; do
            [[ -z "$alias" ]] && continue
            count=$((count + 1))
            servername=$(echo "$alias" | cut -d'/' -f2)
            printf "üéØ \033[1;33m%2d\033[0m. \033[1;32m%-${max_alias_length}s\033[0m | %s | %s | %s\n" \
                "$count" "$servername" "${status_map[$alias]}" "${pw_status_map[$alias]}" "${key_status_map[$alias]}"
        done <<< "${group_servers[$group]}"
    done

    echo -e "\nüß† Total Hosts: \033[1;35m$count\033[0m\n"

    # Clean up temp dir
    rm -rf "$tmpdir"
}

function ssh_server() {
    local hosts groups group selected_host

    # Get all hosts in format group/name
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        return 1
    fi

    # Extract unique groups (portion before '/')
    groups=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u)
    if [[ -z "$groups" ]]; then
        echo "‚ùå No groups found in hosts"
        return 1
    fi


    # Select group from the list of unnique groups
    group=$(echo "$groups" | fzf --prompt="Select group: ")
    if [[ -z "$group" ]]; then
        echo "‚ùå No group selected."
        return 1
    fi

    # Show hosts only from selected group (portion after '/')
    selected_host=$(echo "$hosts" | grep "^$group/" | awk -F/ '{print $2}' | fzf --prompt="Select host in group '$group': ")
    if [[ -z "$selected_host" ]]; then
        echo "‚ùå No host selected."
        return 1
    fi


    ##### this portion is to get password and copy to clipboard #####
    full_host="$group-$selected_host"

    # Extract encrypted password value
    if grep -q "^$full_host=" "$CRED_FILE"; then
        value=$(grep "^$full_host=" "$CRED_FILE" | cut -d'=' -f2-)
    

        # Decrypt password
        decrypted_password=$(decrypt_password "$value")
        if [[ -n "$decrypted_password" ]]; then
            echo "$decrypted_password" | xclip -selection clipboard
        else
            echo "‚ùå Failed to decrypt password for '$full_host'"
            return 1
        fi
        ##### end of password to clipboard portion #####


        # Compose full host (group/name)
        local full_host="$group/$selected_host"
        echo "üîë Connecting to '$selected_host'..."
        ssh "$full_host"



    else
        echo "‚ùå Password is not saved for '$full_host'" >&2

        if [[ -f ~/.ssh/keys/$group-$selected_host ]]; then
            echo "üîë SSH key found for '$full_host'"
            echo "$group $selected_host $full_host"
            ssh -i ~/.ssh/keys/$group-$selected_host "$group/$selected_host"
        else
            echo "‚ùå No SSH key found for '$full_host'"
            return 1
        fi
    fi


}


function edit_server() {
    local hosts groups group name selected_group selected_name
    local old_hostname old_port old_user new_hostname new_port new_user
    local new_group new_name full_old_host full_new_host password encrypted_password

    # Get all hosts in format group/name
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        return 1
    fi

    # Select group first
    groups=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u)
    selected_group=$(echo "$groups" | fzf --prompt="Select group of host to edit: ")
    if [[ -z "$selected_group" ]]; then
        echo "‚ùå No group selected."
        return 1
    fi

    # Select host name in that group
    selected_name=$(echo "$hosts" | grep "^$selected_group/" | awk -F/ '{print $2}' | fzf --prompt="Select host in group '$selected_group' to edit: ")
    if [[ -z "$selected_name" ]]; then
        echo "‚ùå No host selected."
        return 1
    fi

    full_old_host="$selected_group/$selected_name"

    # Get current values from ssh config
    old_hostname=$(awk -v host="$full_old_host" '
        $1 == "Host" && $2 == host { in_block = 1; next }
        in_block && $1 == "Host" { exit }
        in_block && $1 == "HostName" { print $2 }
    ' "$SSH_CONFIG_FILE")

    old_port=$(awk -v host="$full_old_host" '
        $1 == "Host" && $2 == host { in_block = 1; next }
        in_block && $1 == "Host" { exit }
        in_block && $1 == "Port" { print $2 }
    ' "$SSH_CONFIG_FILE")

    old_user=$(awk -v host="$full_old_host" '
        $1 == "Host" && $2 == host { in_block = 1; next }
        in_block && $1 == "Host" { exit }
        in_block && $1 == "User" { print $2 }
    ' "$SSH_CONFIG_FILE")

    # Prompt for edits (default to old values)
    read -p "Group [$selected_group]: " new_group
    new_group=${new_group:-$selected_group}

    read -p "Name [$selected_name]: " new_name
    new_name=${new_name:-$selected_name}

    read -p "HostName [$old_hostname]: " new_hostname
    new_hostname=${new_hostname:-$old_hostname}

    read -p "User [$old_user]: " new_user
    new_user=${new_user:-$old_user}

    while true; do
        read -p "Port [$old_port]: " new_port
        new_port=${new_port:-$old_port}
        if [[ "$new_port" =~ ^[0-9]+$ ]]; then
            break
        else
            echo "‚ùå Port must be a number. Try again."
        fi
    done

    read -rsp "Enter password (leave blank to keep current): " password
    echo

    full_new_host="$new_group/$new_name"


    # Update credentials if password given or if host key changed
    if [[ -n "$password" || "$new_group-$new_name" != "$selected_group-$selected_name" ]]; then
        # Remove old credential entry

        if grep -q "^$selected_group-$selected_name=" "$CRED_FILE"; then
            sed -i "s/^$selected_group-$selected_name=/$new_group-$new_name=/" "$CRED_FILE"

        fi

        if [[ -n "$password" ]]; then
            sed -i "/^$new_group-$new_name=/d" "$CRED_FILE"

            encrypted_password=$(encrypt_password "$password")
            echo "$new_group-$new_name=$encrypted_password" >> "$CRED_FILE"
        else
            echo "‚ùó Password not changed. No new entry added."
        fi
    fi

    # Remove old block from ssh config
    awk -v host="$full_old_host" '
        BEGIN { in_block=0 }
        $1 == "Host" && $2 == host { in_block=1; next }
        $1 == "Host" && in_block == 1 { in_block=0 }
        in_block == 0 { print }
    ' "$SSH_CONFIG_FILE" > "${SSH_CONFIG_FILE}.tmp" && mv "${SSH_CONFIG_FILE}.tmp" "$SSH_CONFIG_FILE"

    # Append updated block
    {
        echo "Host $full_new_host"
        echo "    HostName $new_hostname"
        echo "    User $new_user"
        echo "    Port $new_port"
    } >> "$SSH_CONFIG_FILE"

    #update ssh key if exists
    # read new private key path
    read -p "Enter path to new private key (leave blank to keep current): " private_key
    if [[ -n "$private_key" ]]; then
        mkdir -p "$HOME/.ssh/keys"
        cp "$private_key" "$HOME/.ssh/keys/$new_group-$new_name"
    fi
    # update key file name if group/name changed
    echo "$new_group-$new_name $selected_group-$selected_name"
    if [[ "$new_group-$new_name" != "$selected_group-$selected_name" ]]; then
        if [[ -f "$HOME/.ssh/keys/$selected_group-$selected_name" ]]; then
            mv "$HOME/.ssh/keys/$selected_group-$selected_name" "$HOME/.ssh/keys/$new_group-$new_name"
        fi
    fi



    echo "‚úÖ Host '$full_old_host' updated to '$full_new_host'"
}

function get_password() {
    local hosts groups selected_group selected_name selected_host value decrypted_password full_host

    # Get all hosts in format group/name
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        return 1
    fi

    # Select group first
    groups=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u)
    selected_group=$(echo "$groups" | fzf --prompt="Select group to get password from: ")
    if [[ -z "$selected_group" ]]; then
        echo "‚ùå No group selected."
        return 1
    fi

    # Select host in that group
    selected_name=$(echo "$hosts" | grep "^$selected_group/" | awk -F/ '{print $2}' | fzf --prompt="Select host in group '$selected_group': ")
    if [[ -z "$selected_name" ]]; then
        echo "‚ùå No host selected."
        return 1
    fi

    full_host="$selected_group-$selected_name"

    # Extract encrypted password value
    if grep -q "^$full_host=" "$CRED_FILE"; then
        value=$(grep "^$full_host=" "$CRED_FILE" | cut -d'=' -f2-)
    else
        echo "‚ùå Password is not saved for '$full_host'" >&2
        return 1
    fi

    # Decrypt password
    decrypted_password=$(decrypt_password "$value")
    if [[ -n "$decrypted_password" ]]; then
        echo "üîë Password for '$full_host' is $decrypted_password"
    else
        echo "‚ùå Failed to decrypt password for '$full_host'"
        return 1
    fi
}

function backup() {
    # === Prepare backup directory ===
    rm -rf "$backup_dir"
    mkdir -p "$backup_dir"
    # === Backup SSH config ===
    if [[ ! -f "$SSH_CONFIG_FILE" ]]; then
        echo "‚ùå SSH config file not found at $SSH_CONFIG_FILE"
        exit 1
    else
        cp "$SSH_CONFIG_FILE" "$backup_dir/ssh_config"
        echo "‚úÖ Backed up SSH config"
    fi

    # === Backup credentials file ===
    if [[ ! -f "$CRED_FILE" ]]; then
        echo "‚ö†Ô∏è Credentials file not found at $CRED_FILE ‚Äî continuing without it"
    else
        cp "$CRED_FILE" "$backup_dir/server_credentials"
        echo "‚úÖ Backed up server credentials"
    fi

    # === Backup SSH keys ===
    if [[ -d "$HOME/.ssh/keys" ]]; then
        sudo tar -cf "$backup_dir/ssh-keys-backup.tar" -C "$HOME/.ssh" keys
        echo "‚úÖ Backed up SSH keys"
    else
        echo "‚ö†Ô∏è No SSH keys directory found at $HOME/.ssh/keys, skipping export of keys"
    fi

    # === Backup GPG keyring ===
    if gpg --list-keys "$GPG_RECIPIENT" &>/dev/null; then
        sudo tar -cf "$backup_dir/gnupg-backup.tar" -C ~ .gnupg
        echo "‚úÖ Backed up GPG keyring"
    else
        echo "‚ö†Ô∏è No GPG keys found for recipient '$GPG_RECIPIENT', skipping export of keys"
    fi

    # === Done ===
    echo "üéâ Export complete! Backup saved to: $backup_dir"
}

function restore() {
        
    # === Ensure ~/.ssh directory exists ===
    if [[ ! -d "$HOME/.ssh" ]]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        echo "üìÇ Created ~/.ssh directory"
    fi

    read -rp "üìÇ Enter import directory [./serverctx_backup]: " import_dir
    import_dir="${import_dir:-./serverctx_backup}"

    if [[ ! -d "$import_dir" ]]; then
        echo "‚ùå Import directory '$import_dir' not found."
        exit 1
    fi

    echo "‚úÖ Restoring serverctx from directory: $import_dir"

    if [[ -f "$import_dir/ssh_config" ]]; then
        cp "$import_dir/ssh_config" "$SSH_CONFIG_FILE"
        echo "‚úÖ Restored SSH config"
    else
        echo "‚ö†Ô∏è ssh_config file not found in import directory"
    fi

    if [[ -f "$import_dir/server_credentials" ]]; then
        cp "$import_dir/server_credentials" "$CRED_FILE"
        echo "‚úÖ Restored server credentials"
    else
        echo "‚ö†Ô∏è server_credentials file not found in import directory"
    fi


    # === Restore GPG backup ===
    if [[ -f "$import_dir/gnupg-backup.tar" ]]; then
        sudo rm -rf ~/.gnupg
        tar -xf "$import_dir/gnupg-backup.tar" -C ~
        chmod 700 ~/.gnupg
        chmod 600 ~/.gnupg/*
        echo "‚úÖ Restored GPG keyring"
    else
        echo "‚ö†Ô∏è gnupg-backup.tar not found in import directory"
    fi

    # === Restore SSH keys backup ===
    if [[ -f "$import_dir/ssh-keys-backup.tar" ]]; then
        mkdir -p "$HOME/.ssh/keys"
        tar -xf "$import_dir/ssh-keys-backup.tar" -C "$HOME/.ssh"
        chmod 700 "$HOME/.ssh/keys"
        chmod 600 "$HOME/.ssh/keys"/*
        echo "‚úÖ Restored SSH keys"
    else
        echo "‚ö†Ô∏è ssh-keys-backup.tar not found in import directory"
    fi


    echo "‚úÖ Import complete."
}

function edit_group_name() {
    local old_group new_group hosts host 

    # Get all hosts
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        # return 1
    fi
    printf "Available hosts:\n%s\n" "$hosts"
    # List unique groups
    old_group=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u | fzf --prompt="Select group to rename: ")
    if [[ -z "$old_group" ]]; then
        echo "‚ùå No group selected."
        # return 1
    fi

    read -p "Enter new group name for '$old_group': " new_group
    if [[ -z "$new_group" ]]; then
        echo "‚ùå New group name cannot be empty."
        return 1
    fi

    echo "Renaming group '$old_group' to '$new_group'..."
    sed -i "s/^Host $old_group\//Host $new_group\//" ~/.ssh/config

    # Update credentials
    sed -i "s/^$old_group-/$new_group-/" ~/.ssh/server_credentials

    echo "‚úÖ Group '$old_group' renamed to '$new_group' in config and credentials"
}

function remember(){
    echo "üîë Setting up passwordless SSH authentication..."

    

    # Get all hosts in format group/name
    
    hosts=$(grep '^Host ' "$SSH_CONFIG_FILE" | awk '{print $2}')
    if [[ -z "$hosts" ]]; then
        echo "‚ùå No hosts found"
        return 1
    fi

    # Select group first
    groups=$(echo "$hosts" | awk -F/ '{print $1}' | sort -u)
    selected_group=$(echo "$groups" | fzf --prompt="choose the server to setup passwordless authentication for: ")
    if [[ -z "$selected_group" ]]; then
        echo "‚ùå No group selected."
        return 1
    fi

    # Select host in that group
    selected_name=$(echo "$hosts" | grep "^$selected_group/" | awk -F/ '{print $2}' | fzf --prompt="Select host in group '$selected_group': ")
    if [[ -z "$selected_name" ]]; then
        echo "‚ùå No host selected."
        return 1
    fi

   full_host="$selected_group/$selected_name"

    # Get current values from ssh config
    hostname=$(awk -v host="$full_host" '
        $1 == "Host" && $2 == host { in_block = 1; next }
        in_block && $1 == "Host" { exit }
        in_block && $1 == "HostName" { print $2 }
    ' "$SSH_CONFIG_FILE")

    user=$(awk -v host="$full_host" '
        $1 == "Host" && $2 == host { in_block = 1; next }
        in_block && $1 == "Host" { exit }
        in_block && $1 == "User" { print $2 }
    ' "$SSH_CONFIG_FILE")


    full_host="$selected_group-$selected_name"
    # Extract encrypted password value
    if grep -q "^$full_host=" "$CRED_FILE"; then
        value=$(grep "^$full_host=" "$CRED_FILE" | cut -d'=' -f2-)
    else
        echo "‚ùå Password is not saved for '$full_host'" >&2
        return 1
    fi

    # Decrypt password
    decrypted_password=$(decrypt_password "$value")
    if [[ -n "$decrypted_password" ]]; then
        sshpass -p "$decrypted_password" ssh-copy-id -f "$user@$hostname"  2>&1 >/dev/null
    else
        echo "‚ùå Failed to decrypt password for '$full_host'"
        return 1
    fi
    echo "‚úÖ Passwordless SSH setup complete for $selected_group/$selected_name"
}

function show_help() {
    echo ""
    echo "üñ•Ô∏è  SERVERCTX - Simple SSH Server Manager"
    echo ""
    echo "Usage:"
    echo "  server [command]           Description"
    echo ""
    echo "  server init                Initialize the server manager (install dependencies)"
    echo "  server                     Interactively select and connect to an SSH server"
    echo "  server add                 Add a new SSH server entry"
    echo "  server rm                  Remove an existing SSH server entry"
    echo "  server edit                Edit an existing SSH server entry"
    echo "  server ls                  List all SSH server aliases with ping status"
    echo "  server ssh                 Connect to a server via SSH"
    echo "  server pswd                Get the password for a selected server"
    echo "  server editgroup, -eg      Rename a group of servers"
    echo "  server backup              Backup server information, passwords and encryption keys"
    echo "  server restore             Restore server information, passwords and encryption keys from backup"
    echo "  server remember, -r        activate passwordless authentication for your server"
    echo "  server --help, -h          Show this help message"
    echo ""
}

case "$1" in
    init|initialize|in|-i)
        server_init
        ;;
    add|ad)
        add_server
        ;;
    rm|remove|del|delete)
        remove_server
        ;;
    edit|-e)
        edit_server
        ;;
    list|ls)
        list_servers
        ;;
    ssh|"")
        ssh_server
        ;;
    pswd|password)
        get_password
        ;;
    --help|help|-h)
        show_help
        ;;
    backup|export)
        backup
        ;;
    restore|import)
        restore
        ;;
    editgroup|-eg)
        edit_group_name
        ;;
    remember|-r)
        remember
        ;;
    *)
        echo "‚ùå Unknown command: $1"
        show_help
        ;;
esac
